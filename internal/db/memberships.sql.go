// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: memberships.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptMembership = `-- name: AcceptMembership :one
UPDATE memberships SET accepted_at = NOW(), updated_at = NOW()
WHERE id = $1
RETURNING id, group_id, user_id, role, inviter_id, accepted_at, created_at, updated_at
`

// Accepts a pending invitation
func (q *Queries) AcceptMembership(ctx context.Context, id int64) (*Membership, error) {
	row := q.db.QueryRow(ctx, acceptMembership, id)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.InviterID,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const countAdminsByGroup = `-- name: CountAdminsByGroup :one
SELECT COUNT(*) AS admin_count FROM memberships
WHERE group_id = $1 AND role = 'admin' AND accepted_at IS NOT NULL
`

// Counts active admins in a group (used for last-admin protection)
func (q *Queries) CountAdminsByGroup(ctx context.Context, groupID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countAdminsByGroup, groupID)
	var admin_count int64
	err := row.Scan(&admin_count)
	return admin_count, err
}

const createMembership = `-- name: CreateMembership :one

INSERT INTO memberships (group_id, user_id, role, inviter_id, accepted_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, group_id, user_id, role, inviter_id, accepted_at, created_at, updated_at
`

type CreateMembershipParams struct {
	GroupID    int64              `json:"group_id"`
	UserID     int64              `json:"user_id"`
	Role       string             `json:"role"`
	InviterID  int64              `json:"inviter_id"`
	AcceptedAt pgtype.Timestamptz `json:"accepted_at"`
}

// sqlc queries for memberships table
// See: data-model.md for entity definition
// Creates a new membership (invitation if accepted_at is NULL)
func (q *Queries) CreateMembership(ctx context.Context, arg CreateMembershipParams) (*Membership, error) {
	row := q.db.QueryRow(ctx, createMembership,
		arg.GroupID,
		arg.UserID,
		arg.Role,
		arg.InviterID,
		arg.AcceptedAt,
	)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.InviterID,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteMembership = `-- name: DeleteMembership :exec
DELETE FROM memberships WHERE id = $1
`

// Removes a membership
func (q *Queries) DeleteMembership(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteMembership, id)
	return err
}

const getMembershipByGroupAndUser = `-- name: GetMembershipByGroupAndUser :one
SELECT id, group_id, user_id, role, inviter_id, accepted_at, created_at, updated_at FROM memberships WHERE group_id = $1 AND user_id = $2
`

type GetMembershipByGroupAndUserParams struct {
	GroupID int64 `json:"group_id"`
	UserID  int64 `json:"user_id"`
}

// Retrieves a specific user's membership in a group
func (q *Queries) GetMembershipByGroupAndUser(ctx context.Context, arg GetMembershipByGroupAndUserParams) (*Membership, error) {
	row := q.db.QueryRow(ctx, getMembershipByGroupAndUser, arg.GroupID, arg.UserID)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.InviterID,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMembershipByID = `-- name: GetMembershipByID :one
SELECT id, group_id, user_id, role, inviter_id, accepted_at, created_at, updated_at FROM memberships WHERE id = $1
`

// Retrieves a membership by its ID
func (q *Queries) GetMembershipByID(ctx context.Context, id int64) (*Membership, error) {
	row := q.db.QueryRow(ctx, getMembershipByID, id)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.InviterID,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMembershipWithUser = `-- name: GetMembershipWithUser :one
SELECT
    m.id, m.group_id, m.user_id, m.role, m.inviter_id, m.accepted_at, m.created_at, m.updated_at,
    u.name AS user_name,
    u.username AS user_username,
    i.name AS inviter_name,
    i.username AS inviter_username
FROM memberships m
JOIN users u ON u.id = m.user_id
JOIN users i ON i.id = m.inviter_id
WHERE m.id = $1
`

type GetMembershipWithUserRow struct {
	ID              int64              `json:"id"`
	GroupID         int64              `json:"group_id"`
	UserID          int64              `json:"user_id"`
	Role            string             `json:"role"`
	InviterID       int64              `json:"inviter_id"`
	AcceptedAt      pgtype.Timestamptz `json:"accepted_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	UserName        string             `json:"user_name"`
	UserUsername    string             `json:"user_username"`
	InviterName     string             `json:"inviter_name"`
	InviterUsername string             `json:"inviter_username"`
}

// Gets membership with embedded user info
func (q *Queries) GetMembershipWithUser(ctx context.Context, id int64) (*GetMembershipWithUserRow, error) {
	row := q.db.QueryRow(ctx, getMembershipWithUser, id)
	var i GetMembershipWithUserRow
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.InviterID,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserName,
		&i.UserUsername,
		&i.InviterName,
		&i.InviterUsername,
	)
	return &i, err
}

const isAdmin = `-- name: IsAdmin :one
SELECT EXISTS(
    SELECT 1 FROM memberships
    WHERE group_id = $1 AND user_id = $2 AND role = 'admin' AND accepted_at IS NOT NULL
) AS is_admin
`

type IsAdminParams struct {
	GroupID int64 `json:"group_id"`
	UserID  int64 `json:"user_id"`
}

// Checks if a user is an admin of a group
func (q *Queries) IsAdmin(ctx context.Context, arg IsAdminParams) (bool, error) {
	row := q.db.QueryRow(ctx, isAdmin, arg.GroupID, arg.UserID)
	var is_admin bool
	err := row.Scan(&is_admin)
	return is_admin, err
}

const isMember = `-- name: IsMember :one
SELECT EXISTS(
    SELECT 1 FROM memberships
    WHERE group_id = $1 AND user_id = $2 AND accepted_at IS NOT NULL
) AS is_member
`

type IsMemberParams struct {
	GroupID int64 `json:"group_id"`
	UserID  int64 `json:"user_id"`
}

// Checks if a user is an active member of a group
func (q *Queries) IsMember(ctx context.Context, arg IsMemberParams) (bool, error) {
	row := q.db.QueryRow(ctx, isMember, arg.GroupID, arg.UserID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const listInvitationsWithGroups = `-- name: ListInvitationsWithGroups :many
SELECT
    m.id, m.group_id, m.user_id, m.role, m.inviter_id, m.accepted_at, m.created_at, m.updated_at,
    g.name AS group_name,
    g.handle AS group_handle,
    g.description AS group_description,
    i.name AS inviter_name,
    i.username AS inviter_username
FROM memberships m
JOIN groups g ON g.id = m.group_id
JOIN users i ON i.id = m.inviter_id
WHERE m.user_id = $1 AND m.accepted_at IS NULL
ORDER BY m.created_at DESC
`

type ListInvitationsWithGroupsRow struct {
	ID               int64              `json:"id"`
	GroupID          int64              `json:"group_id"`
	UserID           int64              `json:"user_id"`
	Role             string             `json:"role"`
	InviterID        int64              `json:"inviter_id"`
	AcceptedAt       pgtype.Timestamptz `json:"accepted_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	GroupName        string             `json:"group_name"`
	GroupHandle      string             `json:"group_handle"`
	GroupDescription pgtype.Text        `json:"group_description"`
	InviterName      string             `json:"inviter_name"`
	InviterUsername  string             `json:"inviter_username"`
}

// Lists pending invitations with group and inviter info
func (q *Queries) ListInvitationsWithGroups(ctx context.Context, userID int64) ([]*ListInvitationsWithGroupsRow, error) {
	rows, err := q.db.Query(ctx, listInvitationsWithGroups, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListInvitationsWithGroupsRow{}
	for rows.Next() {
		var i ListInvitationsWithGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.UserID,
			&i.Role,
			&i.InviterID,
			&i.AcceptedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GroupName,
			&i.GroupHandle,
			&i.GroupDescription,
			&i.InviterName,
			&i.InviterUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembershipsByGroup = `-- name: ListMembershipsByGroup :many
SELECT m.id, m.group_id, m.user_id, m.role, m.inviter_id, m.accepted_at, m.created_at, m.updated_at FROM memberships m
WHERE m.group_id = $1
  AND (
    $2::text = 'all'
    OR ($2::text = 'active' AND m.accepted_at IS NOT NULL)
    OR ($2::text = 'pending' AND m.accepted_at IS NULL)
  )
ORDER BY m.role DESC, m.created_at
`

type ListMembershipsByGroupParams struct {
	GroupID int64  `json:"group_id"`
	Status  string `json:"status"`
}

// Lists all memberships in a group with optional status filter
// status: 'all', 'active' (accepted), or 'pending' (not accepted)
func (q *Queries) ListMembershipsByGroup(ctx context.Context, arg ListMembershipsByGroupParams) ([]*Membership, error) {
	rows, err := q.db.Query(ctx, listMembershipsByGroup, arg.GroupID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.UserID,
			&i.Role,
			&i.InviterID,
			&i.AcceptedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembershipsByUser = `-- name: ListMembershipsByUser :many
SELECT id, group_id, user_id, role, inviter_id, accepted_at, created_at, updated_at FROM memberships
WHERE user_id = $1
ORDER BY created_at DESC
`

// Lists all memberships for a user
func (q *Queries) ListMembershipsByUser(ctx context.Context, userID int64) ([]*Membership, error) {
	rows, err := q.db.Query(ctx, listMembershipsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.UserID,
			&i.Role,
			&i.InviterID,
			&i.AcceptedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembershipsWithUsers = `-- name: ListMembershipsWithUsers :many
SELECT
    m.id, m.group_id, m.user_id, m.role, m.inviter_id, m.accepted_at, m.created_at, m.updated_at,
    u.name AS user_name,
    u.username AS user_username,
    i.name AS inviter_name,
    i.username AS inviter_username
FROM memberships m
JOIN users u ON u.id = m.user_id
JOIN users i ON i.id = m.inviter_id
WHERE m.group_id = $1
  AND (
    $2::text = 'all'
    OR ($2::text = 'active' AND m.accepted_at IS NOT NULL)
    OR ($2::text = 'pending' AND m.accepted_at IS NULL)
  )
ORDER BY m.role DESC, u.name
`

type ListMembershipsWithUsersParams struct {
	GroupID int64  `json:"group_id"`
	Status  string `json:"status"`
}

type ListMembershipsWithUsersRow struct {
	ID              int64              `json:"id"`
	GroupID         int64              `json:"group_id"`
	UserID          int64              `json:"user_id"`
	Role            string             `json:"role"`
	InviterID       int64              `json:"inviter_id"`
	AcceptedAt      pgtype.Timestamptz `json:"accepted_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	UserName        string             `json:"user_name"`
	UserUsername    string             `json:"user_username"`
	InviterName     string             `json:"inviter_name"`
	InviterUsername string             `json:"inviter_username"`
}

// Lists memberships with embedded user info
func (q *Queries) ListMembershipsWithUsers(ctx context.Context, arg ListMembershipsWithUsersParams) ([]*ListMembershipsWithUsersRow, error) {
	rows, err := q.db.Query(ctx, listMembershipsWithUsers, arg.GroupID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMembershipsWithUsersRow{}
	for rows.Next() {
		var i ListMembershipsWithUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.UserID,
			&i.Role,
			&i.InviterID,
			&i.AcceptedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserName,
			&i.UserUsername,
			&i.InviterName,
			&i.InviterUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingInvitationsByUser = `-- name: ListPendingInvitationsByUser :many
SELECT id, group_id, user_id, role, inviter_id, accepted_at, created_at, updated_at FROM memberships
WHERE user_id = $1 AND accepted_at IS NULL
ORDER BY created_at DESC
`

// Lists all pending invitations for a user (not yet accepted)
func (q *Queries) ListPendingInvitationsByUser(ctx context.Context, userID int64) ([]*Membership, error) {
	rows, err := q.db.Query(ctx, listPendingInvitationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Membership{}
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.UserID,
			&i.Role,
			&i.InviterID,
			&i.AcceptedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMembershipRole = `-- name: UpdateMembershipRole :one
UPDATE memberships SET role = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, group_id, user_id, role, inviter_id, accepted_at, created_at, updated_at
`

type UpdateMembershipRoleParams struct {
	ID   int64  `json:"id"`
	Role string `json:"role"`
}

// Changes the role of a membership (promote/demote)
func (q *Queries) UpdateMembershipRole(ctx context.Context, arg UpdateMembershipRoleParams) (*Membership, error) {
	row := q.db.QueryRow(ctx, updateMembershipRole, arg.ID, arg.Role)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.Role,
		&i.InviterID,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
