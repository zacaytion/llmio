# Data Model: User Authentication

**Feature**: 001-user-auth | **Date**: 2026-02-01

## Entities

### User

Represents a registered account in the system.

#### Database Schema

```sql
-- migrations/001_create_users.sql

CREATE EXTENSION IF NOT EXISTS citext;

CREATE TABLE users (
    id              BIGSERIAL PRIMARY KEY,
    email           CITEXT NOT NULL UNIQUE,
    name            TEXT NOT NULL,
    username        TEXT NOT NULL UNIQUE,
    password_hash   TEXT NOT NULL,
    email_verified  BOOLEAN NOT NULL DEFAULT FALSE,
    deactivated_at  TIMESTAMPTZ,
    key             TEXT NOT NULL UNIQUE,  -- Public URL key
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT users_email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    CONSTRAINT users_username_format CHECK (username ~* '^[a-z0-9][a-z0-9-]*[a-z0-9]$' AND LENGTH(username) >= 2),
    CONSTRAINT users_name_not_empty CHECK (LENGTH(TRIM(name)) > 0)
);

-- Indexes
CREATE INDEX users_email_idx ON users(email);
CREATE INDEX users_username_idx ON users(username);
CREATE INDEX users_key_idx ON users(key);
CREATE INDEX users_created_at_idx ON users(created_at);

-- Updated at trigger
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at();
```

#### Field Descriptions

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | BIGSERIAL | PK | Auto-incrementing primary key |
| `email` | CITEXT | UNIQUE, NOT NULL | Case-insensitive email address |
| `name` | TEXT | NOT NULL, non-empty | Display name |
| `username` | TEXT | UNIQUE, NOT NULL | URL-safe identifier (generated) |
| `password_hash` | TEXT | NOT NULL | Argon2id hash with embedded salt |
| `email_verified` | BOOLEAN | NOT NULL, default FALSE | Whether email is confirmed |
| `deactivated_at` | TIMESTAMPTZ | nullable | Soft-delete timestamp |
| `key` | TEXT | UNIQUE, NOT NULL | Public URL identifier (22 chars) |
| `created_at` | TIMESTAMPTZ | NOT NULL | Registration timestamp |
| `updated_at` | TIMESTAMPTZ | NOT NULL | Last modification timestamp |

#### Validation Rules

| Field | Rule | Error Message |
|-------|------|---------------|
| email | Valid email format | "Invalid email format" |
| email | Unique (case-insensitive) | "Email already taken" |
| name | Non-empty after trim | "Name is required" |
| password | Min 8 characters (input) | "Password must be at least 8 characters" |
| password | Matches confirmation | "Passwords do not match" |

#### Go Struct (sqlc generated)

```go
// internal/db/models.go (generated by sqlc)

type User struct {
    ID            int64
    Email         string
    Name          string
    Username      string
    PasswordHash  string
    EmailVerified bool
    DeactivatedAt sql.NullTime
    Key           string
    CreatedAt     time.Time
    UpdatedAt     time.Time
}
```

#### DTO (API Response)

```go
// internal/api/dto.go

type UserDTO struct {
    ID            int64     `json:"id"`
    Email         string    `json:"email"`
    Name          string    `json:"name"`
    Username      string    `json:"username"`
    EmailVerified bool      `json:"email_verified"`
    Key           string    `json:"key"`
    CreatedAt     time.Time `json:"created_at"`
}

// FromUser converts db.User to API response (excludes sensitive fields)
func UserDTOFromUser(u *db.User) UserDTO {
    return UserDTO{
        ID:            u.ID,
        Email:         u.Email,
        Name:          u.Name,
        Username:      u.Username,
        EmailVerified: u.EmailVerified,
        Key:           u.Key,
        CreatedAt:     u.CreatedAt,
    }
}
```

### Session (In-Memory)

Represents an authenticated user's active login state. Not persisted to database.

#### Go Struct

```go
// internal/auth/session.go

type Session struct {
    Token     string    // Primary key (32 bytes, base64url)
    UserID    int64     // Foreign key to users.id
    CreatedAt time.Time
    ExpiresAt time.Time // CreatedAt + 7 days
    UserAgent string    // Request User-Agent header
    IPAddress string    // Request IP address
}
```

#### Field Descriptions

| Field | Type | Description |
|-------|------|-------------|
| `Token` | string | Cryptographically random session identifier |
| `UserID` | int64 | References users.id |
| `CreatedAt` | time.Time | Session creation time |
| `ExpiresAt` | time.Time | Session expiration (7 days from creation) |
| `UserAgent` | string | Browser/client identifier for audit |
| `IPAddress` | string | Client IP for audit trail |

#### Lifecycle

```
┌─────────┐     Login      ┌─────────┐     7 days     ┌─────────┐
│ No      │ ──────────────>│ Active  │ ──────────────>│ Expired │
│ Session │                │ Session │                │ (deleted)│
└─────────┘                └─────────┘                └─────────┘
     ^                          │
     │         Logout           │
     └──────────────────────────┘
```

## Relationships

```
┌─────────────────┐
│     User        │
├─────────────────┤
│ id (PK)         │<──────────────┐
│ email (UNIQUE)  │               │
│ username        │               │ 1:N (in-memory)
│ password_hash   │               │
│ ...             │               │
└─────────────────┘               │
                                  │
┌─────────────────┐               │
│    Session      │               │
├─────────────────┤               │
│ token (PK)      │               │
│ user_id (FK)    │───────────────┘
│ expires_at      │
│ ...             │
└─────────────────┘
```

**Cardinality**: One user can have multiple active sessions (e.g., different devices).

## State Transitions

### User Account States

```
┌────────────────┐
│   Registered   │ email_verified = false, deactivated_at = null
└───────┬────────┘
        │ Email verified (manual for MVP)
        v
┌────────────────┐
│    Verified    │ email_verified = true, deactivated_at = null
└───────┬────────┘
        │ Account deactivated
        v
┌────────────────┐
│  Deactivated   │ deactivated_at != null
└────────────────┘
```

### Login Eligibility

```go
func (u *User) CanLogin() (bool, string) {
    if u.DeactivatedAt.Valid {
        return false, "Account is deactivated"
    }
    if !u.EmailVerified {
        return false, "Email verification required"
    }
    return true, ""
}
```

## SQL Queries (sqlc)

```sql
-- internal/db/queries/users.sql

-- name: CreateUser :one
INSERT INTO users (email, name, username, password_hash, key)
VALUES ($1, $2, $3, $4, $5)
RETURNING *;

-- name: GetUserByEmail :one
SELECT * FROM users WHERE email = $1;

-- name: GetUserByID :one
SELECT * FROM users WHERE id = $1;

-- name: GetUserByUsername :one
SELECT * FROM users WHERE username = $1;

-- name: GetUserByKey :one
SELECT * FROM users WHERE key = $1;

-- name: UsernameExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE username = $1);

-- name: EmailExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE email = $1);

-- name: UpdateUserEmailVerified :exec
UPDATE users SET email_verified = $2 WHERE id = $1;

-- name: DeactivateUser :exec
UPDATE users SET deactivated_at = NOW() WHERE id = $1;
```

## Migration Strategy

### From Original Loomio Schema

The original schema uses Devise with `encrypted_password` (bcrypt). For the rewrite:

1. **New users**: Hash with Argon2id directly
2. **Migration path** (future, out of scope):
   - Keep both `encrypted_password` (bcrypt) and `password_hash` (argon2id) columns
   - On login with old password, re-hash with Argon2id and clear bcrypt hash
   - After migration period, drop `encrypted_password` column

### Fields Not Included (Out of Scope)

These fields from the original schema are excluded per YAGNI:

- `reset_password_token/sent_at` - Password reset is out of scope
- `remember_token/created_at` - "Remember me" is out of scope
- `sign_in_count`, `current_sign_in_at`, `last_sign_in_at` - Analytics (future feature)
- `authentication_token`, `unsubscribe_token` - API keys (future feature)
- `failed_attempts`, `locked_at`, `unlock_token` - Lockout (out of scope)
- Avatar fields - Profile feature
- Preferences fields - Settings feature
- Location fields - Profile feature
